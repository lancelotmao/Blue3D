#ifndef HOUYI_SHADERS
#define HOUYI_SHADERS

#define HOUYI_SHADER_COUNT 23

static const char* vshaders[23] = {
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"uniform float uScale;\n"
"uniform float vScale;\n"
"\n"
"uniform float uScroll;\n"
"\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"	gl_PointSize = 5.0;\n"
"	\n"
"	texcoords.st = aTexcoord.st * vec2(uScale, vScale);\n"
"    \n"
"    // x & z\n"
"    vec2 P0 = vec2(-0.5, 0.0);\n"
"    vec2 P1 = vec2(0.5 - uScroll, uScroll * 0.25);\n"
"    float Q0MoveRatio = 0.0 + (0.25 - 0.0) * uScroll;\n"
"    vec2 Q0 = vec2(P0.x + (P1.x - P0.x) * Q0MoveRatio, uScroll * 1.5);\n"
"    vec2 Q1 = vec2(P0.x + (P1.x - P0.x) * (1.0-Q0MoveRatio), uScroll * 0.25);\n"
"    \n"
"    float t = aPosition.x + 0.5;\n"
"    vec2 Q = Q0 + (Q1 - Q0) * t;\n"
"    vec2 P0Q = P0 + (Q - P0) * t;\n"
"    vec2 QP1 = Q + (P1 - Q) * t;\n"
"    \n"
"    vec2 Bezier = P0Q + (QP1 - P0Q) * t;\n"
"    vec3 pos = vec3(aPosition.x + uScroll * (Bezier.x - aPosition.x), aPosition.y, Bezier.y);\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"\n"
"uniform float uScale;\n"
"uniform float vScale;\n"
"\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"    texcoords.st = aTexcoord.st * vec2(uScale, vScale);\n"
"    vec4 pos = vec4(aPosition.xy, 1.0, 1.0);\n"
"    gl_Position = matProjection * (matEye * (matWorld * pos));\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"attribute vec3 aNormal;\n"
"\n"
"uniform mat3 matNormal;\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"uniform float uPointSize;\n"
"uniform int iLightingEnabled;\n"
"uniform vec4 uLightPos[4];\n"
"uniform vec4 uLightColor[4];\n"
"uniform int uLightCount;\n"
"uniform vec4 uAmbientLight;\n"
"uniform vec4 uMaterialAmbient;\n"
"uniform vec4 uMaterialDiffuse;\n"
"uniform vec4 uMaterialSpec;\n"
"uniform float uShininess;\n"
"uniform int uDoubleSided;\n"
"uniform vec3 uEyePosition;\n"
"uniform int uIsLightPosFixed;\n"
"\n"
"uniform float uScale;\n"
"uniform float vScale;\n"
"\n"
"varying vec2 vTexcoords;\n"
"varying vec4 vLightResult;\n"
"varying float vDensity;\n"
"\n"
"void main() {\n"
"	gl_PointSize = uPointSize;\n"
"	vTexcoords.st = vec2(aTexcoord.s * uScale, (1.0 - aTexcoord.t) * vScale);\n"
"    \n"
"    vec4 pos = matWorld * aPosition;\n"
"    vec3 normal = normalize(matNormal * aNormal);\n"
"    \n"
"    if (iLightingEnabled != 0)\n"
"    {\n"
"    	vDensity = 0.0;\n"
"        vLightResult = uAmbientLight * uMaterialAmbient;\n"
"        for (int i = 0;i < uLightCount;++i)\n"
"        {\n"
"	    	vec4 posInLightSpace = uIsLightPosFixed == 0 ? pos : matEye * pos;\n"
"			vec3 normalInLightSpace = uIsLightPosFixed == 0 ? normal : mat3(matEye) * normal;\n"
"	        vec3 lv = normalize(uLightPos[i].xyz - posInLightSpace.xyz);\n"
"	        \n"
"	        if (uDoubleSided != 0)\n"
"	        {\n"
"	        	vDensity = abs(dot(normalInLightSpace, lv));\n"
"	        }\n"
"	        else\n"
"	        {\n"
"	            vDensity = clamp(dot(normalInLightSpace, lv), 0.0, 1.0);\n"
"			}\n"
"				\n"
"	        vLightResult += clamp(vec4(uMaterialDiffuse.xyz * uLightColor[i].xyz * vDensity, uMaterialDiffuse.w), 0.0, 1.0);\n"
"	        \n"
"	        // specular light\n"
"	        if (uMaterialSpec.w > 0.01 && vDensity > 0.0)\n"
"	        {\n"
"	            vec3 camVec = normalize(uEyePosition - posInLightSpace.xyz);\n"
"	            vec3 halfV = normalize(lv + camVec);\n"
"	            float specPower = pow(max(0.0, dot(halfV, normalInLightSpace)), uShininess);\n"
"	            vLightResult += vec4(uMaterialSpec.xyz * normalize(uLightColor[i].xyz) * specPower, 0);\n"
"	        }\n"
"	        vLightResult = clamp(vLightResult, 0.0, 1.0);\n"
"	    }\n"
"    }\n"
"    else\n"
"    {\n"
"        vDensity = 1.0;\n"
"        vLightResult = uMaterialDiffuse;;\n"
"    }\n"
"    \n"
"    vec4 outPos = matProjection * matEye * pos;\n"
"    //outPos.z = outPos.z * outPos.w;\n"
"    gl_Position = outPos;\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matProjection;\n"
"\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"    texcoords.st = aTexcoord.st;\n"
"	gl_Position = matProjection * (matWorld * aPosition);\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"attribute vec3 aNormal;\n"
"attribute vec4 aColor;\n"
"\n"
"uniform mat3 matNormal;\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"uniform int iLightingEnabled;\n"
"uniform vec4 uLightPos[4];\n"
"uniform vec4 uLightColor[4];\n"
"uniform int uLightCount;\n"
"uniform vec4 uAmbientLight;\n"
"uniform vec4 uMaterialAmbient;\n"
"uniform vec4 uMaterialDiffuse;\n"
"uniform vec4 uMaterialSpec;\n"
"uniform float uShininess;\n"
"uniform int uDoubleSided;\n"
"uniform vec3 uEyePosition;\n"
"uniform int uIsLightPosFixed;\n"
"\n"
"uniform float uScale;\n"
"uniform float vScale;\n"
"\n"
"varying vec2 vTexcoords;\n"
"varying vec4 vLightResult;\n"
"varying float vDensity;\n"
"\n"
"void main() {\n"
"	vTexcoords.st = vec2(aTexcoord.s * uScale, (1.0 - aTexcoord.t) * vScale);\n"
"    \n"
"    vec4 pos = matWorld * aPosition;\n"
"    vec3 normal = normalize(matNormal * aNormal);\n"
"    \n"
"    if (iLightingEnabled != 0)\n"
"    {\n"
"    	vDensity = 0.0;\n"
"        vLightResult = uAmbientLight * uMaterialAmbient;\n"
"        int i = 0;\n"
"    	vec4 posInLightSpace = uIsLightPosFixed == 0 ? pos : matEye * pos;\n"
"		vec3 normalInLightSpace = uIsLightPosFixed == 0 ? normal : mat3(matEye) * normal;\n"
"        vec3 lv = normalize(uLightPos[i].xyz - posInLightSpace.xyz);\n"
"        \n"
"        if (uDoubleSided != 0)\n"
"        {\n"
"        	vDensity = abs(dot(normalInLightSpace, lv));\n"
"        }\n"
"        else\n"
"        {\n"
"            vDensity = clamp(dot(normalInLightSpace, lv), 0.0, 1.0);\n"
"		}\n"
"			\n"
"        vLightResult += clamp(vec4(uMaterialDiffuse.xyz * uLightColor[i].xyz * vDensity, uMaterialDiffuse.w), 0.0, 1.0);\n"
"        \n"
"        // specular light\n"
"        if (uMaterialSpec.w > 0.01 && vDensity > 0.0)\n"
"        {\n"
"            vec3 camVec = normalize(uEyePosition - posInLightSpace.xyz);\n"
"            vec3 halfV = normalize(lv + camVec);\n"
"            float specPower = pow(max(0.0, dot(halfV, normalInLightSpace)), uShininess);\n"
"            vLightResult += vec4(uMaterialSpec.xyz * normalize(uLightColor[i].xyz) * specPower, 0);\n"
"        }\n"
"        vLightResult = clamp(vLightResult, 0.0, 1.0);\n"
"    }\n"
"    else\n"
"    {\n"
"        vDensity = 1.0;\n"
"        vLightResult = uMaterialDiffuse + aColor;\n"
"    }\n"
"    \n"
"    vec4 outPos = matProjection * matEye * pos;\n"
"    //outPos.z = outPos.z * outPos.w;\n"
"    gl_Position = outPos;\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"attribute vec3 aNormal;\n"
"attribute vec3 aTangent;\n"
"\n"
"uniform mat3 matNormal;\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"uniform int iLightingEnabled;\n"
"uniform vec4 uLightPos[4];\n"
"uniform vec4 uLightColor[4];\n"
"uniform vec4 uMaterialDiffuse;\n"
"uniform float uScale;\n"
"\n"
"uniform float vScale;\n"
"\n"
"varying vec2 vTexcoords;\n"
"varying vec4 vLightResult;\n"
"varying float vDensity;\n"
"\n"
"varying vec3 vTangent;\n"
"\n"
"void main() {\n"
"	vTexcoords.st = vec2(aTexcoord.s * uScale, (1.0 - aTexcoord.t) * vScale);\n"
"    \n"
"    vec4 pos = matWorld * aPosition;\n"
"    vec3 normal = matNormal * aNormal;\n"
"    \n"
"    if (iLightingEnabled != 0)\n"
"    {\n"
"        vec4 posInLightSpace = matEye * pos;\n"
"        vec3 normalInLightSpace = mat3(matEye) * normal;\n"
"        vec3 lv = normalize(uLightPos[0].xyz - posInLightSpace.xyz);\n"
"        \n"
"        vDensity = clamp(dot(normalInLightSpace, lv), 0.0, 1.0);\n"
"        vLightResult = clamp(vec4(uMaterialDiffuse.xyz * uLightColor[0].xyz * vDensity, uMaterialDiffuse.w), 0.0, 1.0);\n"
"    }\n"
"    else\n"
"    {\n"
"        vDensity = 1.0;\n"
"        vLightResult = uMaterialDiffuse;\n"
"    }\n"
"    \n"
"    vTangent = aTangent;\n"
"    \n"
"    vec4 outPos = matProjection * matEye * pos;\n"
"    outPos.z = outPos.z * outPos.w;\n"
"    gl_Position = outPos;\n"
"}\n"
, 
"attribute vec2 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"uniform float tick;\n"
"uniform float px;\n"
"uniform float py;\n"
"uniform float R;\n"
"uniform float waveLength;\n"
"uniform float waveMag;\n"
"\n"
"varying float density;\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"    float pi = 3.14159265358979323846264;\n"
"	gl_PointSize = 5.0;\n"
"    vec4 posWorld = matWorld * vec4(aPosition, 0.0, 1.0);\n"
"    texcoords.st = aTexcoord.st;\n"
"    \n"
"    float l = length(posWorld.y);\n"
"    float z = posWorld.z;\n"
"    bool enhance = false;\n"
"    vec3 P = vec3(px, py, 0);\n"
"    float factor = 2.0;\n"
"    float distanceToWave = R - length(posWorld.xyz - P);\n"
"    if (distanceToWave > -waveLength / 2.0 && distanceToWave < waveLength / 2.0)\n"
"    {\n"
"        z = sin(distanceToWave) * waveMag;\n"
"        enhance = true;\n"
"        factor = 1.0;\n"
"    }\n"
"    else if (R > 0.0)\n"
"    {\n"
"        z = 1.0 * (cos(l / 5.0 + tick)/tick);\n"
"        enhance = true;\n"
"    }\n"
"    \n"
"    if (enhance)\n"
"    {\n"
"        float a = pi / 2.0 * (1.0 - abs(z));\n"
"        vec3 normal = vec3(0.0, sin(a), cos(a));\n"
"        vec3 light = vec3(0, 0, 5);\n"
"        float added = 1.0 + dot(normal, normalize(light)) / factor;\n"
"        density = clamp(added, 0.3, 10.0);\n"
"    }\n"
"    else\n"
"    {\n"
"        density = 1.0;\n"
"    }\n"
"    \n"
"	gl_Position = matProjection * (matEye * vec4(posWorld.xy, z, 1.0));\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"attribute vec3 aNormal;\n"
"attribute vec4 aIndex;\n"
"attribute vec4 aWeight;\n"
"\n"
"uniform mat3 matNormal;\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"uniform mat4 matLightProjection;\n"
"uniform mat4 matLightView;\n"
"\n"
"uniform int iBoneEnabled;\n"
"uniform mat4 matBindShape;\n"
"uniform mat4 matBone[48];\n"
"\n"
"uniform int uIsLightPosFixed;\n"
"\n"
"varying vec2 texcoords;\n"
"varying vec4 vLCPos;\n"
"varying vec4 vPos;\n"
"varying vec3 vNormal;\n"
"\n"
"void main() {\n"
"	gl_PointSize = 5.0;\n"
"    texcoords = vec2(aTexcoord.s, 1.0 - aTexcoord.t);\n"
"    \n"
"    vec4 pos = aPosition;\n"
"    vec3 normal = normalize(aNormal);\n"
"    if (iBoneEnabled != 0)\n"
"    {\n"
"        vec4 posBindShape = matBindShape * aPosition;\n"
"        vec3 normalBindShape = mat3(matBindShape) * normal;\n"
"        \n"
"        int index = int(aIndex.x);\n"
"        vec4 boneSpacePos = (matBone[index] * posBindShape) * aWeight.x;\n"
"        mat3 mn = mat3(matBone[index]);\n"
"        vec3 boneSpaceNormal = (mn * normalBindShape) * aWeight.x;\n"
"        \n"
"        if (aWeight.y > 0.01)\n"
"        {\n"
"        	index = int(aIndex.y);\n"
"	        boneSpacePos += (matBone[index] * posBindShape) * aWeight.y;\n"
"	        mn = mat3(matBone[index]);\n"
"	        boneSpaceNormal += (mn * normalBindShape) * aWeight.y;\n"
"	    }\n"
"        \n"
"        if (aWeight.z > 0.01)\n"
"        {\n"
"        	index = int(aIndex.z);\n"
"	        boneSpacePos += (matBone[index] * posBindShape) * aWeight.z;\n"
"	        mn = mat3(matBone[index]);\n"
"	        boneSpaceNormal += (mn * normalBindShape) * aWeight.z;\n"
"	    }\n"
"        \n"
"        if (aWeight.w > 0.01)\n"
"        {\n"
"        	index = int(aIndex.w);\n"
"	        boneSpacePos += (matBone[index] * posBindShape) * aWeight.w;\n"
"	        mn = mat3(matBone[index]);\n"
"	        boneSpaceNormal += (mn * normalBindShape) * aWeight.w;\n"
"	    }\n"
"        \n"
"    	pos = vec4(boneSpacePos.xyz, 1.0);\n"
"        normal = boneSpaceNormal;\n"
"    }\n"
"    \n"
"    // transform position and normal to world\n"
"    pos = matWorld * pos;\n"
"    normal = normalize(matNormal * normalize(normal));\n"
"    \n"
"    vPos = uIsLightPosFixed == 0 ? pos : matEye * pos;\n"
"	vNormal = uIsLightPosFixed == 0 ? normal : mat3(matEye) * normal;\n"
"\n"
"    vLCPos = matLightProjection * matLightView * vec4(pos.xyz, 1.0);\n"
"    \n"
"    vec4 outPos = matProjection * matEye * pos;\n"
"    //outPos.z = outPos.z * outPos.w;\n"
"    gl_Position = outPos;\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"varying vec2 vTexcoord;\n"
"\n"
"void main() {\n"
"    vTexcoord.st = aTexcoord;\n"
"    vec4 pos = vec4(aPosition.xy, 1.0, 1.0);\n"
"    gl_Position = matProjection * matEye * matWorld * pos;\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"attribute vec3 aNormal;\n"
"\n"
"uniform mat3 matNormal;\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"uniform float uScale;\n"
"uniform float vScale;\n"
"uniform int uIsLightPosFixed;\n"
"\n"
"varying vec2 vTexcoords;\n"
"varying vec4 vPos;\n"
"varying vec3 vNormal;\n"
"\n"
"void main() {\n"
"	vTexcoords.st = vec2(aTexcoord.s * uScale, (1.0 - aTexcoord.t) * vScale);\n"
"    \n"
"    vec4 pos = matWorld * aPosition;\n"
"    vec3 normal = normalize(matNormal * aNormal);\n"
"    \n"
"    vPos = uIsLightPosFixed == 0 ? pos : matEye * pos;\n"
"	vNormal = uIsLightPosFixed == 0 ? normal : mat3(matEye) * normal;\n"
"    \n"
"    vec4 outPos = matProjection * matEye * pos;\n"
"    //outPos.z = outPos.z * outPos.w;\n"
"    gl_Position = outPos;\n"
"}\n"
, 
"attribute vec3 aPosition;\n"
"\n"
"uniform mat4 matEyeProjection;\n"
"uniform mat3 matEyeNormal;\n"
"uniform vec3 cam_pos;\n"
"\n"
"varying vec3 ReflectDir;\n"
"\n"
"void main() {\n"
"    vec3 pos = matEyeNormal * aPosition.xyz;\n"
"    ReflectDir = normalize(aPosition);\n"
"    gl_Position = matEyeProjection * vec4(pos, 1.0);\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec4 aIndex;\n"
"attribute vec4 aWeight;\n"
"\n"
"uniform mat4 matLightProjection;\n"
"uniform mat4 matLightView;\n"
"\n"
"uniform int iBoneEnabled;\n"
"uniform mat4 matBindShape;\n"
"uniform mat4 matBone[48];\n"
"\n"
"varying vec4 vPos;\n"
"\n"
"void main() {\n"
"    vec4 pos = aPosition;\n"
"    \n"
"    if (iBoneEnabled != 0)\n"
"    {\n"
"        vec4 posBindShape = matBindShape * aPosition;\n"
"        \n"
"        int index = int(aIndex.x);\n"
"        vec4 boneSpacePos = (matBone[index] * posBindShape) * aWeight.x;\n"
"        \n"
"        if (aWeight.y > 0.01)\n"
"        {\n"
"            index = int(aIndex.y);\n"
"            boneSpacePos += (matBone[index] * posBindShape) * aWeight.y;\n"
"        }\n"
"        \n"
"        if (aWeight.z > 0.01)\n"
"        {\n"
"            index = int(aIndex.z);\n"
"            boneSpacePos += (matBone[index] * posBindShape) * aWeight.z;\n"
"        }\n"
"        \n"
"        if (aWeight.w > 0.01)\n"
"        {\n"
"            index = int(aIndex.w);\n"
"            boneSpacePos += (matBone[index] * posBindShape) * aWeight.w;\n"
"        }\n"
"        \n"
"        pos = vec4(boneSpacePos.xyz, 1.0);\n"
"    }\n"
"    \n"
"    vPos = matLightProjection * matLightView * pos;\n"
"    gl_Position = vPos;\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"attribute vec3 aNormal;\n"
"attribute vec4 aIndex;\n"
"attribute vec4 aWeight;\n"
"\n"
"uniform mat3 matNormal;\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"uniform mat4 matLightProjection;\n"
"uniform mat4 matLightView;\n"
"\n"
"uniform vec3 uEyePosition;\n"
"\n"
"uniform int iBoneEnabled;\n"
"uniform mat4 matBindShape;\n"
"uniform mat4 matBone[48];\n"
"\n"
"uniform int iLightingEnabled;\n"
"uniform int iAttenuationEnabled;\n"
"uniform int light_two_sided;\n"
"uniform vec4 uAmbientLight;\n"
"uniform int uLightCount;\n"
"uniform int uIsLightPosFixed;\n"
"uniform vec4 uLightPos[4];\n"
"uniform vec4 uLightColor[4];\n"
"uniform vec4 uMaterialAmbient;\n"
"uniform vec4 uMaterialDiffuse;\n"
"uniform vec4 uMaterialSpec;\n"
"uniform float uShininess;\n"
"uniform int uDoubleSided;\n"
"\n"
"varying vec4 lightResult;\n"
"varying vec2 texcoords;\n"
"varying float vDensity;\n"
"varying vec4 vLCPos;\n"
"\n"
"void main() {\n"
"	gl_PointSize = 5.0;\n"
"    texcoords = vec2(aTexcoord.s, 1.0 - aTexcoord.t);\n"
"    \n"
"    vec4 pos = aPosition;\n"
"    vec3 normal = normalize(aNormal);\n"
"    if (iBoneEnabled != 0)\n"
"    {\n"
"        vec4 posBindShape = matBindShape * aPosition;\n"
"        vec3 normalBindShape = mat3(matBindShape) * normal;\n"
"        \n"
"        int index = int(aIndex.x);\n"
"        vec4 boneSpacePos = (matBone[index] * posBindShape) * aWeight.x;\n"
"        mat3 mn = mat3(matBone[index]);\n"
"        vec3 boneSpaceNormal = (mn * normalBindShape) * aWeight.x;\n"
"        \n"
"        if (aWeight.y > 0.01)\n"
"        {\n"
"        	index = int(aIndex.y);\n"
"	        boneSpacePos += (matBone[index] * posBindShape) * aWeight.y;\n"
"	        mn = mat3(matBone[index]);\n"
"	        boneSpaceNormal += (mn * normalBindShape) * aWeight.y;\n"
"	    }\n"
"        \n"
"        if (aWeight.z > 0.01)\n"
"        {\n"
"        	index = int(aIndex.z);\n"
"	        boneSpacePos += (matBone[index] * posBindShape) * aWeight.z;\n"
"	        mn = mat3(matBone[index]);\n"
"	        boneSpaceNormal += (mn * normalBindShape) * aWeight.z;\n"
"	    }\n"
"        \n"
"        if (aWeight.w > 0.01)\n"
"        {\n"
"        	index = int(aIndex.w);\n"
"	        boneSpacePos += (matBone[index] * posBindShape) * aWeight.w;\n"
"	        mn = mat3(matBone[index]);\n"
"	        boneSpaceNormal += (mn * normalBindShape) * aWeight.w;\n"
"	    }\n"
"        \n"
"    	pos = vec4(boneSpacePos.xyz, 1.0);\n"
"        normal = boneSpaceNormal;\n"
"    }\n"
"    \n"
"    // transform position and normal to world\n"
"    pos = matWorld * pos;\n"
"    normal = normalize(matNormal * normalize(normal));\n"
"\n"
"    vLCPos = matLightProjection * matLightView * vec4(pos.xyz, 1.0);\n"
"    \n"
"    if (iLightingEnabled != 0)\n"
"    {\n"
"        vDensity = 0.0;\n"
"        lightResult = uAmbientLight * uMaterialAmbient;\n"
"        for (int i = 0;i < uLightCount;++i)\n"
"        {\n"
"            vec4 posInLightSpace = uIsLightPosFixed == 0 ? pos : matEye * pos;\n"
"            vec3 normalInLightSpace = uIsLightPosFixed == 0 ? normal : mat3(matEye) * normal;\n"
"            vec3 lv = normalize(uLightPos[i].w == 0.0 ? uLightPos[i].xyz : (uLightPos[i].xyz - posInLightSpace.xyz));\n"
"            \n"
"            float atten = (iAttenuationEnabled == 0) ? 1.0 : 1.0 / length(uLightPos[i].xyz - posInLightSpace.xyz);\n"
"            float density = 1.0;\n"
"            if (uDoubleSided != 0)\n"
"            {\n"
"            	density = abs(dot(normalInLightSpace, lv));\n"
"            }\n"
"            else\n"
"            {\n"
"                density = clamp(dot(normalInLightSpace, lv), 0.0, 1.0);\n"
"			}\n"
"            vDensity += density * atten;\n"
"            lightResult += vec4(uMaterialDiffuse.xyz * uLightColor[i].xyz * density, uMaterialDiffuse.w) * atten;\n"
"            \n"
"            // specular light\n"
"            if (uMaterialSpec.w > 0.01 && density > 0.0)\n"
"            {\n"
"                float specPower = 0.0;\n"
"                vec3 camVec = normalize(uEyePosition - posInLightSpace.xyz);\n"
"                specPower = pow(max(0.0, dot(reflect(-lv, normalInLightSpace), camVec)), uShininess);\n"
"                lightResult += vec4(uMaterialSpec.xyz * normalize(uLightColor[i].xyz) * specPower, uMaterialSpec.w);\n"
"            }\n"
"        }\n"
"        lightResult = clamp(lightResult, 0.0, 1.0);\n"
"    }\n"
"    else\n"
"    {\n"
"    	lightResult = uMaterialDiffuse;\n"
"        vDensity = 1.0;\n"
"    }\n"
"    \n"
"    vec4 outPos = matProjection * matEye * pos;\n"
"    //outPos.z = outPos.z * outPos.w;\n"
"    gl_Position = outPos;\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"uniform float px;\n"
"uniform float py;\n"
"uniform float R;\n"
"uniform float waveLength;\n"
"uniform float waveMag;\n"
"\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"	gl_PointSize = 5.0;\n"
"    vec3 pos = aPosition.xyz;\n"
"    texcoords.st = aTexcoord.st;\n"
"    \n"
"    vec3 P = vec3(px, py, 0);\n"
"    float distanceToWave = R - length(pos - P);\n"
"    if (distanceToWave > -waveLength / 2.0 && distanceToWave < waveLength / 2.0)\n"
"    {\n"
"    	pos.z = sin(distanceToWave) * waveMag;\n"
"    }\n"
"	gl_Position = matProjection * (matEye * (matWorld * vec4(pos.xyz, 1.0)));\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"attribute vec3 aNormal;\n"
"\n"
"uniform mat3 matNormal;\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"uniform int iLightingEnabled;\n"
"uniform vec4 uLightPos[4];\n"
"uniform vec4 uLightColor[4];\n"
"uniform vec4 uMaterialDiffuse;\n"
"uniform float uScale;\n"
"\n"
"uniform float vScale;\n"
"\n"
"varying vec2 vTexcoords;\n"
"varying vec4 vLightResult;\n"
"varying float vDensity;\n"
"\n"
"void main() {\n"
"	vTexcoords.st = vec2(aTexcoord.s * uScale, (1.0 - aTexcoord.t) * vScale);\n"
"    \n"
"    vec4 pos = matWorld * aPosition;\n"
"    vec3 normal = matNormal * aNormal;\n"
"    \n"
"    if (iLightingEnabled != 0)\n"
"    {\n"
"        vec4 posInLightSpace = matEye * pos;\n"
"        vec3 normalInLightSpace = mat3(matEye) * normal;\n"
"        vec3 lv = normalize(uLightPos[0].xyz - posInLightSpace.xyz);\n"
"        \n"
"        vDensity = clamp(dot(normalInLightSpace, lv), 0.0, 1.0);\n"
"        vLightResult = clamp(vec4(uMaterialDiffuse.xyz * uLightColor[0].xyz * vDensity, uMaterialDiffuse.w), 0.0, 1.0);\n"
"    }\n"
"    else\n"
"    {\n"
"        vDensity = 1.0;\n"
"        vLightResult = uMaterialDiffuse;\n"
"    }\n"
"    \n"
"    vec4 outPos = matProjection * matEye * pos;\n"
"    outPos.z = outPos.z * outPos.w;\n"
"    gl_Position = outPos;\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"attribute vec3 aNormal;\n"
"\n"
"uniform mat3 matNormal;\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"uniform float uPointSize;\n"
"uniform int iLightingEnabled;\n"
"uniform vec4 uLightPos[4];\n"
"uniform vec4 uLightColor[4];\n"
"uniform int uLightCount;\n"
"uniform vec4 uAmbientLight;\n"
"uniform vec4 uMaterialAmbient;\n"
"uniform vec4 uMaterialDiffuse;\n"
"uniform vec4 uMaterialSpec;\n"
"uniform float uShininess;\n"
"uniform int uDoubleSided;\n"
"uniform vec3 uEyePosition;\n"
"uniform int uIsLightPosFixed;\n"
"\n"
"uniform float uScale;\n"
"uniform float vScale;\n"
"\n"
"varying vec2 vTexcoords;\n"
"\n"
"void main() {\n"
"	gl_PointSize = uPointSize;\n"
"	vTexcoords.st = vec2(aTexcoord.s * uScale, (1.0 - aTexcoord.t) * vScale);\n"
"    \n"
"    vec4 pos = matWorld * aPosition;\n"
"    \n"
"    vec4 outPos = matProjection * matEye * pos;\n"
"    //outPos.z = outPos.z * outPos.w;\n"
"    gl_Position = outPos;\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"varying vec2 vTexcoord;\n"
"\n"
"void main() {\n"
"    vTexcoord.st = aTexcoord.st;\n"
"    vec4 pos = vec4(aPosition.xy, 1.0, 1.0);\n"
"    gl_Position = matProjection * matEye * matWorld * pos;\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"varying vec2 vTexCoord;\n"
"\n"
"void main() {\n"
"    vec3 pos = (matWorld * aPosition).xyz;\n"
"    vTexCoord = vec2(sign(pos));\n"
"    gl_Position = matProjection * (matEye * vec4(pos.xy, 0.0, 1.0));\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec3 aNormal;\n"
"\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"uniform vec3 uEyePosition;\n"
"\n"
"varying vec3 vReflect;\n"
"\n"
"void main() {\n"
"    vec3 pos = (matWorld * aPosition).xyz;\n"
"    vec3 norm = normalize(mat3(matWorld) * aNormal);\n"
"    vReflect = reflect(pos - uEyePosition, norm);\n"
"    gl_Position = matProjection * (matEye * vec4(pos, 1.0));\n"
"}\n"
, 
"// http://wdnuon.blogspot.kr/2010/05/implementing-ibooks-page-curling-using.html\n"
"// http://www2.parc.com/istl/groups/uir/publications/items/UIR-2004-10-Hong-DeformingPages.pdf\n"
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"uniform float uScale;\n"
"uniform float vScale;\n"
"\n"
"// actually we need pass sin(theta), cos(theta), sin(rho), cos(rho)\n"
"// but here we keep the original to illustrate the algorithm\n"
"uniform float A;\n"
"uniform float theta;\n"
"uniform float rho;\n"
"uniform float offsetx;\n"
"uniform float offsety;\n"
"uniform float targetx;\n"
"uniform float targety;\n"
"\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"	gl_PointSize = 5.0;\n"
"	\n"
"	texcoords.st = aTexcoord.st * vec2(uScale, vScale);\n"
"    vec3 pos = aPosition.xyz;\n"
"    vec3 outv = pos;\n"
"    \n"
"    pos.x -= offsetx;\n"
"    pos.y -= offsety;\n"
"    \n"
"    // Radius of the circle circumscribed by vertex (vi.x, vi.y) around A on the x-y plane\n"
"    float R     = sqrt(pos.x * pos.x + (pos.y - A) * (pos.y - A)); \n"
"    // Now get the radius of the cone cross section intersected by our vertex in 3D space.\n"
"    float r     = R * sin(theta);                       \n"
"    // Angle subtended by arc |ST| on the cone cross section.\n"
"    float beta  = asin(pos.x / R) / sin(theta);       \n"
"   \n"
"    vec3 v1;\n"
"    // *** MAGIC!!! ***\n"
"    v1.x  = r * sin(beta);\n"
"    v1.y  = R + A - r * (1.0 - cos(beta)) * sin(theta); \n"
"    v1.z  = r * (1.0 - cos(beta)) * cos(theta);\n"
"    // Apply a basic rotation transform around the y axis to rotate the curled page.\n"
"    // These two steps could be combined through simple substitution, but are left\n"
"    // separate to keep the math simple for debugging and illustrative purposes.\n"
"    outv.x = (v1.x * cos(rho) - v1.z * sin(rho));\n"
"    outv.y =  v1.y;\n"
"    outv.z = (v1.x * sin(rho) + v1.z * cos(rho));\n"
"    \n"
"	gl_Position = matProjection * (matEye * (matWorld * vec4(outv.x + targetx, outv.y + targety, outv.z, 1.0)));\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"attribute vec3 aNormal;\n"
"\n"
"uniform mat3 matNormal;\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"uniform float uScale;\n"
"uniform float vScale;\n"
"uniform int uIsLightPosFixed;\n"
"\n"
"varying vec2 vTexcoords;\n"
"varying vec4 vPos;\n"
"varying vec3 vNormal;\n"
"\n"
"void main() {\n"
"	vTexcoords.st = vec2(aTexcoord.s * uScale, (1.0 - aTexcoord.t) * vScale);\n"
"    \n"
"    vec4 pos = matWorld * aPosition;\n"
"    vec3 normal = normalize(matNormal * aNormal);\n"
"    \n"
"    vPos = uIsLightPosFixed == 0 ? pos : matEye * pos;\n"
"	vNormal = uIsLightPosFixed == 0 ? normal : mat3(matEye) * normal;\n"
"    \n"
"    vec4 outPos = matProjection * matEye * pos;\n"
"    //outPos.z = outPos.z * outPos.w;\n"
"    gl_Position = outPos;\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"attribute vec3 aNormal;\n"
"attribute vec3 aTangent;\n"
"\n"
"uniform mat3 matNormal;\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"uniform float uScale;\n"
"uniform float vScale;\n"
"uniform int uIsLightPosFixed;\n"
"uniform vec4 uLightPos[4];\n"
"\n"
"varying vec2 vTexcoords;\n"
"varying vec4 vPos;\n"
"varying vec3 vNormal;\n"
"varying vec3 vLightPos;\n"
"\n"
"void main() {\n"
"	vTexcoords.st = vec2(aTexcoord.s * uScale, (1.0 - aTexcoord.t) * vScale);\n"
"    \n"
"    vec4 pos = matWorld * aPosition;\n"
"    vec3 normal = normalize(matNormal * aNormal);\n"
"    \n"
"    vPos = uIsLightPosFixed == 0 ? pos : matEye * pos;\n"
"	vNormal = uIsLightPosFixed == 0 ? normal : mat3(matEye) * normal;\n"
"	\n"
"    vec3 t = normalize (matNormal * aTangent);\n"
"    vec3 b = cross (vNormal, t);\n"
"    \n"
"    vec3 lightDir = normalize (uLightPos[0].xyz - vPos.xyz);\n"
"    vec3 v;\n"
"    v.x = dot (lightDir, t);\n"
"    v.y = dot (lightDir, b);\n"
"    v.z = dot (lightDir, vNormal);\n"
"    vLightPos = normalize (v);\n"
"    \n"
"    vec4 outPos = matProjection * matEye * pos;\n"
"    //outPos.z = outPos.z * outPos.w;\n"
"    gl_Position = outPos;\n"
"}\n"
, 
"attribute vec4 aPosition;\n"
"attribute vec2 aTexcoord;\n"
"\n"
"uniform mat4 matWorld;\n"
"uniform mat4 matEye;\n"
"uniform mat4 matProjection;\n"
"\n"
"uniform float tick;\n"
"\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"	gl_PointSize = 5.0;\n"
"    texcoords.st = aTexcoord.st;\n"
"    \n"
"	gl_Position = matProjection * (matEye * (matWorld * aPosition));\n"
"}\n"
};

static const char* pshaders[23] = {
"precision mediump float;\n"
"\n"
"uniform sampler2D tex;\n"
"\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"    vec4 texColor = texture2D(tex, texcoords.st);\n"
"    gl_FragColor = texColor;\n"
"    //gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform vec4 color;\n"
"uniform sampler2D tex;\n"
"\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"    vec4 texColor = texture2D(tex, texcoords.st);\n"
"    gl_FragColor = texColor;\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform sampler2D tex;\n"
"\n"
"// 0 No Texture; 1 Combine; 2 Replace; 3 Modulate; 4 minus texcoord transparent\n"
"uniform int uTextureMode;\n"
"\n"
"varying vec2 vTexcoords;\n"
"varying vec4 vLightResult;\n"
"varying float vDensity;\n"
"\n"
"void main() {\n"
"	if (uTextureMode == 0)\n"
"    {\n"
"        gl_FragColor = vLightResult;\n"
"    }\n"
"    else\n"
"    {\n"
"        vec4 texColor = texture2D(tex, vTexcoords);\n"
"        vec4 baseColor = texColor * vDensity;\n"
"        if (uTextureMode == 1)\n"
"        {\n"
"            gl_FragColor = vec4(baseColor.xyz + vLightResult.xyz, texColor.w);\n"
"        }\n"
"        else if(uTextureMode == 2)\n"
"        {\n"
"            gl_FragColor = vec4(baseColor.xyz, texColor.w);\n"
"        }\n"
"        else if(uTextureMode == 3)\n"
"        {\n"
"            gl_FragColor = baseColor * vLightResult;\n"
"        }\n"
"        else if(uTextureMode == 4)\n"
"        {\n"
"            if (vTexcoords.s < 0.0 || vTexcoords.t <= 0.0)\n"
"            {\n"
"                gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
"            }\n"
"            else\n"
"            {\n"
"                gl_FragColor = vec4(baseColor.xyz + vLightResult.xyz, texColor.w);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform sampler2D tex;\n"
"uniform float width;\n"
"uniform float height;\n"
"uniform float sampleRate;\n"
"\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"    float invW = 1.0 / width;\n"
"    float invH = 1.0 / height;\n"
"    \n"
"    if (sampleRate == 2.0)\n"
"    {\n"
"        // OGSS\n"
"//        gl_FragColor = 0.25 * texture2D(tex, vec2(texcoords.s, texcoords.t)) \n"
"//        + 0.25 * texture2D(tex, vec2(texcoords.s + invW, texcoords.t))\n"
"//        + 0.25 * texture2D(tex, vec2(texcoords.s, texcoords.t + invH))\n"
"//        + 0.25 * texture2D(tex, vec2(texcoords.s + invW, texcoords.t + invH));\n"
"        \n"
"        // RGSS 45\n"
"//        gl_FragColor = 0.25 * texture2D(tex, vec2(texcoords.s, texcoords.t)) \n"
"//        + 0.25 * texture2D(tex, vec2(texcoords.s - invW, texcoords.t))\n"
"//        + 0.25 * texture2D(tex, vec2(texcoords.s + invW, texcoords.t))\n"
"//        + 0.25 * texture2D(tex, vec2(texcoords.s, texcoords.t + invH));\n"
"        \n"
"        // RGSS 27\n"
"        float angle = radians(27.0);\n"
"        gl_FragColor = 0.25 * texture2D(tex, vec2(texcoords.s, texcoords.t)) \n"
"        + 0.25 * texture2D(tex, vec2(texcoords.s + invW * cos(angle), texcoords.t + invH * sin(angle)))\n"
"        + 0.25 * texture2D(tex, vec2(texcoords.s + invW - invW * sin(angle), texcoords.t + invH + invH * sin(angle)))\n"
"        + 0.25 * texture2D(tex, vec2(texcoords.s - invW * sin(angle), texcoords.t + invH * cos(angle)));\n"
"    }\n"
"    else if (sampleRate == 3.0)\n"
"    {\n"
"        gl_FragColor = 0.125 * texture2D(tex, vec2(texcoords.s - invW, texcoords.t))\n"
"                        + 0.125 * texture2D(tex, vec2(texcoords.s, texcoords.t - invH))\n"
"                        + 0.125 * texture2D(tex, vec2(texcoords.s + invW, texcoords.t))\n"
"                        + 0.125 * texture2D(tex, vec2(texcoords.s, texcoords.t + invH))\n"
"                        + 0.25 * texture2D(tex, vec2(texcoords.s, texcoords.t))\n"
"                        + 0.0625 * texture2D(tex, vec2(texcoords.s + invW, texcoords.t + invH))\n"
"                        + 0.0625 * texture2D(tex, vec2(texcoords.s - invW, texcoords.t - invH))\n"
"                        + 0.0625 * texture2D(tex, vec2(texcoords.s - invW, texcoords.t + invH))\n"
"                        + 0.0625 * texture2D(tex, vec2(texcoords.s + invW, texcoords.t - invH));\n"
"    } else {\n"
"        gl_FragColor = texture2D(tex, texcoords.st);\n"
"    }\n"
"    \n"
"    //gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);  \n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform sampler2D tex;\n"
"\n"
"// 0 No Texture; 1 Combine; 2 Replace; 3 Modulate\n"
"uniform int uTextureMode;\n"
"\n"
"varying vec2 vTexcoords;\n"
"varying vec4 vLightResult;\n"
"varying float vDensity;\n"
"\n"
"void main() {\n"
"	if (uTextureMode == 0)\n"
"    {\n"
"        gl_FragColor = vLightResult;\n"
"    }\n"
"    else\n"
"    {\n"
"        vec4 texColor = texture2D(tex, vTexcoords);\n"
"        vec4 baseColor = texColor * vDensity;\n"
"        if (uTextureMode == 1)\n"
"        {\n"
"            gl_FragColor = vec4(baseColor.xyz + vLightResult.xyz, texColor.w);\n"
"        }\n"
"        else if(uTextureMode == 2)\n"
"        {\n"
"            gl_FragColor = vec4(baseColor.xyz, texColor.w);\n"
"        }\n"
"        else if(uTextureMode == 3)\n"
"        {\n"
"            gl_FragColor = baseColor * vLightResult;\n"
"        }\n"
"        else if(uTextureMode == 4)\n"
"        {\n"
"            if (vTexcoords.s < 0.0 || vTexcoords.t <= 0.0)\n"
"            {\n"
"                gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
"            }\n"
"            else\n"
"            {\n"
"                gl_FragColor = vec4(baseColor.xyz + vLightResult.xyz, texColor.w);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform sampler2D tex;\n"
"\n"
"// 0 No Texture; 1 Combine; 2 Replace; 3 Modulate\n"
"uniform int uTextureMode;\n"
"\n"
"varying vec2 vTexcoords;\n"
"varying vec4 vLightResult;\n"
"varying float vDensity;\n"
"varying vec3 vTangent;\n"
"\n"
"void main() {\n"
"	vec3 base = vec3(0.6823, 0.7961, 1.0);\n"
"	float len = length(vTangent) * 2.0 - 1.0;\n"
"	gl_FragColor = vec4(base * vDensity, len);\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform sampler2D tex;\n"
"uniform vec3 color;\n"
"\n"
"varying float density;\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"    vec4 texColor = texture2D(tex, texcoords.st);\n"
"    gl_FragColor = texColor * density;\n"
"	//gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n"
"}\n"
, 
"precision highp float;\n"
"\n"
"uniform sampler2D tex;\n"
"uniform vec2 uTexScroll;\n"
"// 0 No Texture; 1 Combine; 2 Replace; 3 Modulate\n"
"uniform int uTextureMode;\n"
"\n"
"// shadow uniforms\n"
"uniform int uShadowEnabled;\n"
"uniform sampler2D texShadowMap;\n"
"uniform float width;\n"
"uniform float height;\n"
"uniform float uShadowFactor;\n"
"uniform int uIsOccluder;\n"
"// accepted value is 1, 4, 16\n"
"uniform int uShadowMappingAASampleRate;\n"
"\n"
"// lighting\n"
"uniform int iLightingEnabled;\n"
"uniform int iAttenuationEnabled;\n"
"uniform int light_two_sided;\n"
"uniform vec4 uAmbientLight;\n"
"uniform int uLightCount;\n"
"uniform vec4 uLightPos[4];\n"
"uniform vec4 uLightColor[4];\n"
"uniform vec4 uMaterialAmbient;\n"
"uniform vec4 uMaterialDiffuse;\n"
"uniform vec4 uMaterialSpec;\n"
"uniform float uShininess;\n"
"uniform int uDoubleSided;\n"
"uniform vec3 uEyePosition;\n"
"\n"
"varying vec2 texcoords;\n"
"varying vec4 vLCPos;\n"
"varying vec4 vPos;\n"
"varying vec3 vNormal;\n"
"\n"
"void main() {\n"
"	int count = 0;\n"
"	int shadowAASampleRate = uShadowMappingAASampleRate;\n"
"	\n"
"	if (uShadowEnabled != 0)\n"
"	{\n"
"	    float invW = 1.0 / width;\n"
"	    float invH = 1.0 / height;\n"
"	    \n"
"	    vec4 normalizedLCPos = vLCPos / vLCPos.w;\n"
"	    float LCZ = normalizedLCPos.z;\n"
"	    vec2 shadowCoord = (normalizedLCPos.st + 1.0) / 2.0;\n"
"	    \n"
"	    vec4 shadowTexColor = texture2D(texShadowMap, shadowCoord.st);\n"
"	    if (shadowTexColor.s > 0.0 && shadowTexColor.s < 1.0\n"
"	        && shadowTexColor.t > 0.0 && shadowTexColor.t < 1.0)\n"
"	    {\n"
"	        if(uIsOccluder != 0)\n"
"	        {\n"
"	            // for occluder, avoid z fighting by loosing condition\n"
"	            LCZ -= 0.01;\n"
"	        }\n"
"	        \n"
"	        if (uShadowMappingAASampleRate == 16)\n"
"	        {\n"
"	            for (int i = 0;i < 4;++i)\n"
"	            {\n"
"	                for (int j = 0;j < 4;++j)\n"
"	                {\n"
"	                    vec4 stc = texture2D(texShadowMap,\n"
"	                            vec2(shadowCoord.s + (-1.5+float(i)) * invW, shadowCoord.t + (-1.5+float(j)) * invH));\n"
"	    \n"
"	                    if (LCZ > stc.r)\n"
"	                    {\n"
"	                        count++;\n"
"	                    }\n"
"	                }\n"
"	            }\n"
"	        }\n"
"	        else if (uShadowMappingAASampleRate == 4)\n"
"	        {\n"
"	            for (int i = 0;i < 2;++i)\n"
"	            {\n"
"	                for (int j = 0;j < 2;++j)\n"
"	                {\n"
"	                    vec4 stc = texture2D(texShadowMap,\n"
"	                            vec2(shadowCoord.s + (-0.5+float(i)) * invW, shadowCoord.t + (-0.5+float(j)) * invH));\n"
"	    \n"
"	                    if (LCZ > stc.r)\n"
"	                    {\n"
"	                        count++;\n"
"	                    }\n"
"	                }\n"
"	            }\n"
"	        }\n"
"	        else\n"
"	        {\n"
"	            shadowAASampleRate = 1;\n"
"	            vec4 stc = texture2D(texShadowMap, shadowCoord.st);\n"
"	            if (LCZ > stc.r)\n"
"	            {\n"
"	                count++;\n"
"	            }\n"
"	        }\n"
"	    }\n"
"	}\n"
"    \n"
"    // flip Y\n"
"    vec2 tc = texcoords + uTexScroll;\n"
"    \n"
"    float vDensity = 0.0;\n"
"    vec4 lightResult = vec4(0.0, 0.0, 0.0, 0.0);\n"
"    if (iLightingEnabled != 0)\n"
"    {\n"
"        lightResult = uAmbientLight * uMaterialAmbient;\n"
"        vec4 posInLightSpace = vPos;\n"
"        vec3 normalInLightSpace = normalize(vNormal);\n"
"        for (int i = 0;i < uLightCount;++i)\n"
"        {\n"
"            vec3 lv = normalize(uLightPos[i].w == 0.0 ? uLightPos[i].xyz : (uLightPos[i].xyz - posInLightSpace.xyz));\n"
"            \n"
"            float atten = (iAttenuationEnabled == 0) ? 1.0 : 1.0 / length(uLightPos[i].xyz - posInLightSpace.xyz);\n"
"            float density = 1.0;\n"
"            if (uDoubleSided != 0)\n"
"            {\n"
"            	density = abs(dot(normalInLightSpace, lv));\n"
"            }\n"
"            else\n"
"            {\n"
"                density = clamp(dot(normalInLightSpace, lv), 0.0, 1.0);\n"
"			}\n"
"            vDensity += density * atten;\n"
"            lightResult += vec4(uMaterialDiffuse.xyz * uLightColor[i].xyz * density, uMaterialDiffuse.w) * atten;\n"
"            \n"
"            // specular light\n"
"            if (uMaterialSpec.w > 0.01 && density > 0.0)\n"
"            {\n"
"                float specPower = 0.0;\n"
"                vec3 camVec = normalize(uEyePosition - posInLightSpace.xyz);\n"
"                vec3 halfV = normalize(lv + camVec);\n"
"                specPower = pow(max(0.0, dot(halfV, normalInLightSpace)), uShininess);\n"
"                lightResult += vec4(uMaterialSpec.xyz * normalize(uLightColor[i].xyz) * specPower, 0);\n"
"            }\n"
"        }\n"
"        lightResult = clamp(lightResult, 0.0, 1.0);\n"
"    }\n"
"    else\n"
"    {\n"
"    	lightResult = uMaterialDiffuse;\n"
"        vDensity = 1.0;\n"
"    }\n"
"    \n"
"    if (count == 0)\n"
"    {\n"
"    	if (uTextureMode == 0)\n"
"    	{\n"
"    		gl_FragColor = lightResult;\n"
"    	}\n"
"    	else\n"
"    	{\n"
"	        vec4 texColor = texture2D(tex, tc + uTexScroll);\n"
"	        vec4 baseColor = texColor * vDensity;\n"
"	        if (uTextureMode == 1)\n"
"	        {\n"
"	            gl_FragColor = baseColor + lightResult;\n"
"	        }\n"
"	        else if(uTextureMode == 2)\n"
"	        {\n"
"	            gl_FragColor = vec4(baseColor.xyz, texColor.w);\n"
"	        }\n"
"	        else\n"
"	        {\n"
"	            gl_FragColor = baseColor * lightResult;\n"
"	        }\n"
"	    }\n"
"    }\n"
"    else if (uIsOccluder != 0)\n"
"    {\n"
"        vec4 texColor = texture2D(tex, tc);\n"
"        vec4 baseColor = texColor * vDensity + lightResult;\n"
"        // self shadowing. avoid completely black\n"
"        gl_FragColor = vec4(baseColor.xyz * uShadowFactor, baseColor.w);\n"
"    }\n"
"    else\n"
"    {\n"
"        gl_FragColor = vec4(0.0, 0.0, 0.0, float(count) / float(shadowAASampleRate));\n"
"    }\n"
"}\n"
, 
"#extension GL_OES_EGL_image_external : require\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform samplerExternalOES tex;\n"
"\n"
"varying vec2 vTexcoord;\n"
"\n"
"void main() {\n"
"	vec2 tc = vTexcoord;\n"
"    vec4 texColor = texture2D(tex, tc);\n"
"    gl_FragColor = texColor;\n"
"}\n"
, 
"precision highp float;\n"
"\n"
"uniform sampler2D tex;\n"
"\n"
"// 0 No Texture; 1 Combine; 2 Replace; 3 Modulate\n"
"uniform int uTextureMode;\n"
"\n"
"uniform int iLightingEnabled;\n"
"uniform int iAttenuationEnabled;\n"
"uniform vec4 uLightPos[4];\n"
"uniform vec4 uLightColor[4];\n"
"uniform int uLightCount;\n"
"uniform vec4 uAmbientLight;\n"
"uniform vec4 uMaterialAmbient;\n"
"uniform vec4 uMaterialDiffuse;\n"
"uniform vec4 uMaterialSpec;\n"
"uniform float uShininess;\n"
"uniform int uDoubleSided;\n"
"uniform vec3 uEyePosition;\n"
"uniform int uIsLightPosFixed;\n"
"\n"
"varying vec2 vTexcoords;\n"
"varying vec4 vPos;\n"
"varying vec3 vNormal;\n"
"\n"
"void main() {\n"
"\n"
"	float vDensity = 0.0;\n"
"    vec4 lightResult = vec4(0.0, 0.0, 0.0, 0.0);\n"
"    if (iLightingEnabled != 0)\n"
"    {\n"
"        lightResult = uAmbientLight * uMaterialAmbient;\n"
"        vec4 posInLightSpace = vPos;\n"
"        vec3 normalInLightSpace = normalize(vNormal);\n"
"        int i = 0;\n"
"        vec3 lv = normalize(uLightPos[i].w == 0.0 ? uLightPos[i].xyz : (uLightPos[i].xyz - posInLightSpace.xyz));\n"
"        \n"
"        float atten = (iAttenuationEnabled == 0) ? 1.0 : 1.0 / length(uLightPos[i].xyz - posInLightSpace.xyz);\n"
"        float density = 1.0;\n"
"        if (uDoubleSided != 0)\n"
"        {\n"
"        	density = abs(dot(normalInLightSpace, lv));\n"
"        }\n"
"        else\n"
"        {\n"
"            density = clamp(dot(normalInLightSpace, lv), 0.0, 1.0);\n"
"		}\n"
"        vDensity += density * atten;\n"
"        lightResult += vec4(uMaterialDiffuse.xyz * uLightColor[i].xyz * density, uMaterialDiffuse.w) * atten;\n"
"        \n"
"        // specular light\n"
"        if (uMaterialSpec.w > 0.01 && density > 0.0)\n"
"        {\n"
"            float specPower = 0.0;\n"
"            vec3 camVec = normalize(uEyePosition - posInLightSpace.xyz);\n"
"            vec3 halfV = normalize(lv + camVec);\n"
"            specPower = pow(max(0.0, dot(halfV, normalInLightSpace)), uShininess);\n"
"            lightResult += vec4(uMaterialSpec.xyz * normalize(uLightColor[i].xyz) * specPower, 0);\n"
"        }\n"
"        lightResult = clamp(lightResult, 0.0, 1.0);\n"
"    }\n"
"    else\n"
"    {\n"
"    	lightResult = uMaterialDiffuse;\n"
"        vDensity = 1.0;\n"
"    }\n"
"    \n"
"	if (uTextureMode == 0)\n"
"    {\n"
"        gl_FragColor = lightResult;\n"
"    }\n"
"    else\n"
"    {\n"
"        vec4 texColor = texture2D(tex, vTexcoords);\n"
"        vec4 baseColor = texColor * vDensity;\n"
"        if (uTextureMode == 1)\n"
"        {\n"
"            gl_FragColor = baseColor + lightResult;\n"
"        }\n"
"        else if(uTextureMode == 2)\n"
"        {\n"
"            gl_FragColor = vec4(baseColor.xyz, texColor.w);\n"
"        }\n"
"        else if(uTextureMode == 3)\n"
"        {\n"
"            gl_FragColor = baseColor * lightResult;\n"
"        }\n"
"        else if(uTextureMode == 4)\n"
"        {\n"
"            if (vTexcoords.s < 0.0 || vTexcoords.t <= 0.0)\n"
"            {\n"
"                gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
"            }\n"
"            else\n"
"            {\n"
"                gl_FragColor = vec4(baseColor.xyz + lightResult.xyz, texColor.w);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform samplerCube EnvMap;\n"
"\n"
"varying vec3  ReflectDir;\n"
"\n"
"void main()\n"
"{\n"
"    vec3 envColor = vec3(textureCube(EnvMap, ReflectDir));\n"
"    gl_FragColor = vec4(envColor, 1.0);\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"varying vec4 vPos;\n"
"\n"
"void main() {\n"
"    // because we are projecting onto light coordinate\n"
"    // w can be not normalized. We must normalize it\n"
"    float normalizedDistance  = vPos.z / vPos.w;\n"
"    \n"
"    // TODO encode float z into RGB\n"
"    gl_FragColor = vec4(normalizedDistance, normalizedDistance, normalizedDistance, 1.0);\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform sampler2D tex;\n"
"uniform vec2 uTexScroll;\n"
"// 0 No Texture; 1 Combine; 2 Replace; 3 Modulate\n"
"uniform int uTextureMode;\n"
"\n"
"// shadow uniforms\n"
"uniform int uShadowEnabled;\n"
"uniform sampler2D texShadowMap;\n"
"uniform float width;\n"
"uniform float height;\n"
"uniform float uShadowFactor;\n"
"uniform int uIsOccluder;\n"
"// accepted value is 1, 4, 16\n"
"uniform int uShadowMappingAASampleRate;\n"
"\n"
"varying vec4 lightResult;\n"
"varying vec2 texcoords;\n"
"varying float vDensity;\n"
"varying vec4 vLCPos;\n"
"\n"
"void main() {\n"
"	int count = 0;\n"
"	int shadowAASampleRate = uShadowMappingAASampleRate;\n"
"	\n"
"	if (uShadowEnabled != 0)\n"
"	{\n"
"	    float invW = 1.0 / width;\n"
"	    float invH = 1.0 / height;\n"
"	    \n"
"	    vec4 normalizedLCPos = vLCPos / vLCPos.w;\n"
"	    float LCZ = normalizedLCPos.z;\n"
"	    vec2 shadowCoord = (normalizedLCPos.st + 1.0) / 2.0;\n"
"	    \n"
"	    vec4 shadowTexColor = texture2D(texShadowMap, shadowCoord.st);\n"
"	    if (shadowTexColor.s > 0.0 && shadowTexColor.s < 1.0\n"
"	        && shadowTexColor.t > 0.0 && shadowTexColor.t < 1.0)\n"
"	    {\n"
"	        if(uIsOccluder != 0)\n"
"	        {\n"
"	            // for occluder, avoid z fighting by loosing condition\n"
"	            LCZ -= 0.01;\n"
"	        }\n"
"	        \n"
"	        if (uShadowMappingAASampleRate == 16)\n"
"	        {\n"
"	            for (int i = 0;i < 4;++i)\n"
"	            {\n"
"	                for (int j = 0;j < 4;++j)\n"
"	                {\n"
"	                    vec4 stc = texture2D(texShadowMap,\n"
"	                            vec2(shadowCoord.s + (-1.5+float(i)) * invW, shadowCoord.t + (-1.5+float(j)) * invH));\n"
"	    \n"
"	                    if (LCZ > stc.r)\n"
"	                    {\n"
"	                        count++;\n"
"	                    }\n"
"	                }\n"
"	            }\n"
"	        }\n"
"	        else if (uShadowMappingAASampleRate == 4)\n"
"	        {\n"
"	            for (int i = 0;i < 2;++i)\n"
"	            {\n"
"	                for (int j = 0;j < 2;++j)\n"
"	                {\n"
"	                    vec4 stc = texture2D(texShadowMap,\n"
"	                            vec2(shadowCoord.s + (-0.5+float(i)) * invW, shadowCoord.t + (-0.5+float(j)) * invH));\n"
"	    \n"
"	                    if (LCZ > stc.r)\n"
"	                    {\n"
"	                        count++;\n"
"	                    }\n"
"	                }\n"
"	            }\n"
"	        }\n"
"	        else\n"
"	        {\n"
"	            shadowAASampleRate = 1;\n"
"	            vec4 stc = texture2D(texShadowMap, shadowCoord.st);\n"
"	            if (LCZ > stc.r)\n"
"	            {\n"
"	                count++;\n"
"	            }\n"
"	        }\n"
"	    }\n"
"	}\n"
"    \n"
"    // flip Y\n"
"    vec2 tc = texcoords + uTexScroll;\n"
"    \n"
"    if (count == 0)\n"
"    {\n"
"    	if (uTextureMode == 0)\n"
"    	{\n"
"    		gl_FragColor = lightResult;\n"
"    	}\n"
"    	else\n"
"    	{\n"
"	        vec4 texColor = texture2D(tex, tc + uTexScroll);\n"
"	        vec4 baseColor = texColor * vDensity;\n"
"	        if (uTextureMode == 1)\n"
"	        {\n"
"	            gl_FragColor = baseColor + lightResult;\n"
"	        }\n"
"	        else if(uTextureMode == 2)\n"
"	        {\n"
"	            gl_FragColor = vec4(baseColor.xyz, texColor.w);\n"
"	        }\n"
"	        else\n"
"	        {\n"
"	            gl_FragColor = baseColor * lightResult;\n"
"	        }\n"
"	    }\n"
"//        gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n"
"    }\n"
"    else if (uIsOccluder != 0)\n"
"    {\n"
"        vec4 texColor = texture2D(tex, tc);\n"
"        vec4 baseColor = texColor * vDensity + lightResult;\n"
"        // self shadowing. avoid completely black\n"
"        gl_FragColor = vec4(baseColor.xyz * uShadowFactor, baseColor.w);\n"
"    }\n"
"    else\n"
"    {\n"
"        gl_FragColor = vec4(0.0, 0.0, 0.0, float(count) / float(shadowAASampleRate));\n"
"    }\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform sampler2D tex;\n"
"\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"    //vec4 texColor = texture2D(tex, texcoords.st);\n"
"    //gl_FragColor = texColor;\n"
"    gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform sampler2D tex;\n"
"\n"
"// 0 No Texture; 1 Combine; 2 Replace; 3 Modulate\n"
"uniform int uTextureMode;\n"
"\n"
"varying vec2 vTexcoords;\n"
"varying vec4 vLightResult;\n"
"varying float vDensity;\n"
"\n"
"void main() {\n"
"	if (uTextureMode == 0)\n"
"    {\n"
"        gl_FragColor = vLightResult;\n"
"    }\n"
"    else\n"
"    {\n"
"        vec4 texColor = texture2D(tex, vTexcoords);\n"
"        vec4 baseColor = texColor * vDensity;\n"
"        if (uTextureMode == 1)\n"
"        {\n"
"            gl_FragColor = baseColor + vLightResult;\n"
"        }\n"
"        else if(uTextureMode == 2)\n"
"        {\n"
"            gl_FragColor = vec4(baseColor.xyz, texColor.w);\n"
"        }\n"
"        else\n"
"        {\n"
"            gl_FragColor = baseColor * vLightResult;\n"
"        }\n"
"    }\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform float uTick;\n"
"uniform sampler2D tex;\n"
"\n"
"varying vec2 vTexcoords;\n"
"\n"
"void main() {\n"
"	float sinT = sin(uTick/2.0);\n"
"    vec4 texColor = texture2D(tex, vTexcoords);\n"
"    float a = texColor.w;\n"
"    if (a < 1.0)\n"
"    {\n"
"    	gl_FragColor = vec4(texColor.xyz + vec3(sinT, sinT, sinT) * (1.0-a), 1.0);\n"
"    }\n"
"    else\n"
"    {\n"
"	    gl_FragColor = texColor;\n"
"	}\n"
"	\n"
"	//gl_FragColor = vec4(vec3(sinT, sinT, sinT), 1.0);\n"
"}\n"
, 
"#extension GL_OES_EGL_image_external : require\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform samplerExternalOES tex;\n"
"uniform int uIsMirrored;\n"
"\n"
"varying vec2 vTexcoord;\n"
"\n"
"vec2 HmdWarp(vec2 in01)\n"
"{\n"
"	vec4 HmdWarpParam = vec4(2.5, 0.5, 0.25, 0.05);\n"
"    vec2 lensCenter = vec2(0.5, 0.5);\n"
"    vec2 theta = (in01 - lensCenter) * 2.0;\n"
"    float rSq = theta.x * theta.x + theta.y * theta.y;\n"
"    vec2 rvector = theta * (HmdWarpParam.x + HmdWarpParam.y * rSq + HmdWarpParam.z * rSq * rSq + HmdWarpParam.w * rSq * rSq * rSq);\n"
"    return lensCenter + 0.15 * rvector;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec2 tc = HmdWarp(vTexcoord);\n"
"	if (tc.s < 0.0 || tc.s > 1.0 || tc.t < 0.0 || tc.t > 1.0) {\n"
"		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	} else {\n"
"		if (uIsMirrored == 1)\n"
"		{\n"
"			tc = vec2(tc.s * 0.5 + 0.25, tc.t);\n"
"		}\n"
"		gl_FragColor = texture2D(tex, tc); \n"
"	}\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform sampler2D tex;\n"
"uniform vec3 color;\n"
"\n"
"uniform float time_0_X;\n"
"uniform float sideFade;\n"
"uniform float sideFadeSharpness;\n"
"uniform float wobbleScale;\n"
"uniform float burnSpeed;\n"
"uniform float randomnessRate;\n"
"uniform float yFade;\n"
"uniform float xScale;\n"
"uniform float yScale;\n"
"\n"
"varying vec2 vTexCoord;\n"
"\n"
"//\n"
"// Description : Array and textureless GLSL 2D/3D/4D simplex \n"
"//               noise functions.\n"
"//      Author : Ian McEwan, Ashima Arts.\n"
"//  Maintainer : ijm\n"
"//     Lastmod : 20110822 (ijm)\n"
"//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n"
"//               Distributed under the MIT License. See LICENSE file.\n"
"//               https://github.com/ashima/webgl-noise\n"
"// \n"
"\n"
"vec3 mod289(vec3 x) {\n"
"  return x - floor(x * (1.0 / 289.0)) * 289.0;\n"
"}\n"
"\n"
"vec4 mod289(vec4 x) {\n"
"  return x - floor(x * (1.0 / 289.0)) * 289.0;\n"
"}\n"
"\n"
"vec4 permute(vec4 x) {\n"
"     return mod289(((x*34.0)+1.0)*x);\n"
"}\n"
"\n"
"vec4 taylorInvSqrt(vec4 r)\n"
"{\n"
"  return 1.79284291400159 - 0.85373472095314 * r;\n"
"}\n"
"\n"
"float snoise(vec3 v)\n"
"  { \n"
"  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n"
"  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n"
"\n"
"// First corner\n"
"  vec3 i  = floor(v + dot(v, C.yyy) );\n"
"  vec3 x0 =   v - i + dot(i, C.xxx) ;\n"
"\n"
"// Other corners\n"
"  vec3 g = step(x0.yzx, x0.xyz);\n"
"  vec3 l = 1.0 - g;\n"
"  vec3 i1 = min( g.xyz, l.zxy );\n"
"  vec3 i2 = max( g.xyz, l.zxy );\n"
"\n"
"  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n"
"  //   x1 = x0 - i1  + 1.0 * C.xxx;\n"
"  //   x2 = x0 - i2  + 2.0 * C.xxx;\n"
"  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n"
"  vec3 x1 = x0 - i1 + C.xxx;\n"
"  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n"
"  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n"
"\n"
"// Permutations\n"
"  i = mod289(i); \n"
"  vec4 p = permute( permute( permute( \n"
"             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n"
"           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n"
"           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n"
"\n"
"// Gradients: 7x7 points over a square, mapped onto an octahedron.\n"
"// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n"
"  float n_ = 0.142857142857; // 1.0/7.0\n"
"  vec3  ns = n_ * D.wyz - D.xzx;\n"
"\n"
"  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n"
"\n"
"  vec4 x_ = floor(j * ns.z);\n"
"  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n"
"\n"
"  vec4 x = x_ *ns.x + ns.yyyy;\n"
"  vec4 y = y_ *ns.x + ns.yyyy;\n"
"  vec4 h = 1.0 - abs(x) - abs(y);\n"
"\n"
"  vec4 b0 = vec4( x.xy, y.xy );\n"
"  vec4 b1 = vec4( x.zw, y.zw );\n"
"\n"
"  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n"
"  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n"
"  vec4 s0 = floor(b0)*2.0 + 1.0;\n"
"  vec4 s1 = floor(b1)*2.0 + 1.0;\n"
"  vec4 sh = -step(h, vec4(0.0));\n"
"\n"
"  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n"
"  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n"
"\n"
"  vec3 p0 = vec3(a0.xy,h.x);\n"
"  vec3 p1 = vec3(a0.zw,h.y);\n"
"  vec3 p2 = vec3(a1.xy,h.z);\n"
"  vec3 p3 = vec3(a1.zw,h.w);\n"
"\n"
"//Normalise gradients\n"
"  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n"
"  p0 *= norm.x;\n"
"  p1 *= norm.y;\n"
"  p2 *= norm.z;\n"
"  p3 *= norm.w;\n"
"\n"
"// Mix final noise value\n"
"  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n"
"  m = m * m;\n"
"  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n"
"                                dot(p2,x2), dot(p3,x3) ) );\n"
"  }\n"
"\n"
"float noisecom(vec3 ni, float time)\n"
"{\n"
"    float n = snoise(ni);\n"
"    n += 0.5 * snoise(ni * 2.0 - vec3(0.0, 0.0, time*1.4)); \n"
"    n += 0.25 * snoise(ni * 4.0 - vec3(0.0, 0.0, time*2.0)); \n"
"    n += 0.125 * snoise(ni * 8.0 - vec3(0.0, 0.0, time*2.8)); \n"
"    n += 0.0625 * snoise(ni * 16.0 - vec3(0.0, 0.0, time*4.0)); \n"
"    n += 0.03125 * snoise(ni * 32.0 - vec3(0.0, 0.0, time*5.6)); \n"
"    n = n * 0.7;\n"
"    return n;\n"
"}\n"
"\n"
"float saturate(float inValue)\n"
"{\n"
"   return clamp(inValue, 0.0, 1.0);\n"
"}\n"
"\n"
"void main() {\n"
"    // Wobble for the noise to get a more realistic appearance\n"
"   float wobbX = 2.0 * cos(6.0 * vTexCoord.x + time_0_X);\n"
"   float wobbY = 7.0 * (1.0 - vTexCoord.y) * (1.0 - vTexCoord.y);\n"
"   float wobble = sin(time_0_X + wobbX + wobbY);\n"
" \n"
"   vec3 coord;\n"
" \n"
"   // Wobble more in the flames than at the base\n"
"   coord.x = xScale * vTexCoord.x + wobbleScale * (vTexCoord.y + 1.0) * wobble;\n"
" \n"
"   // Create an upwards movement\n"
"   coord.y = yScale * vTexCoord.y - burnSpeed * time_0_X;\n"
" \n"
"   // Move in Z to get some randomness\n"
"   coord.z = randomnessRate * time_0_X;\n"
"   float noisy = noisecom(coord, time_0_X);\n"
"\n"
"   // Define the shape of the fire\n"
"   float t = sideFadeSharpness * (1.0 - sideFade * vTexCoord.x * vTexCoord.x);\n"
"\n"
"   // Get the color out of it all\n"
"   float heat = saturate(t + noisy - yFade * vTexCoord.y);\n"
"   vec4 flame = texture2D(tex, vec2(heat,0.0));\n"
"   \n"
"	gl_FragColor = flame;\n"
"	//gl_FragColor = vec4(noisy, noisy, noisy, 1.0);\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform vec4 color;\n"
"uniform samplerCube EnvMap;\n"
"\n"
"varying vec3 vReflect;\n"
"\n"
"void main() {\n"
"    vec3 envColor = vec3(textureCube(EnvMap, vReflect));\n"
"    gl_FragColor = vec4(color.xyz * 0.4 + envColor * 0.6, color.w);\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform sampler2D tex;\n"
"\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"    vec4 texColor = texture2D(tex, texcoords.st);\n"
"    gl_FragColor = texColor;\n"
"    //gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n"
"}\n"
, 
"precision highp float;\n"
"\n"
"uniform sampler2D tex;\n"
"\n"
"// 0 No Texture; 1 Combine; 2 Replace; 3 Modulate\n"
"uniform int uTextureMode;\n"
"\n"
"uniform int iLightingEnabled;\n"
"uniform int iAttenuationEnabled;\n"
"uniform vec4 uLightPos[4];\n"
"uniform vec4 uLightColor[4];\n"
"uniform int uLightCount;\n"
"uniform vec4 uAmbientLight;\n"
"uniform vec4 uMaterialAmbient;\n"
"uniform vec4 uMaterialDiffuse;\n"
"uniform vec4 uMaterialSpec;\n"
"uniform float uShininess;\n"
"uniform int uDoubleSided;\n"
"uniform vec3 uEyePosition;\n"
"uniform int uIsLightPosFixed;\n"
"\n"
"varying vec2 vTexcoords;\n"
"varying vec4 vPos;\n"
"varying vec3 vNormal;\n"
"\n"
"void main() {\n"
"\n"
"	float vDensity = 0.0;\n"
"    vec4 lightResult = vec4(0.0, 0.0, 0.0, 0.0);\n"
"    if (iLightingEnabled != 0)\n"
"    {\n"
"        lightResult = uAmbientLight * uMaterialAmbient;\n"
"        vec4 posInLightSpace = vPos;\n"
"        vec3 normalInLightSpace = normalize(vNormal);\n"
"        for (int i = 0;i < uLightCount;++i)\n"
"        {\n"
"            vec3 lv = normalize(uLightPos[i].w == 0.0 ? uLightPos[i].xyz : (uLightPos[i].xyz - posInLightSpace.xyz));\n"
"            \n"
"            float atten = (iAttenuationEnabled == 0) ? 1.0 : 1.0 / length(uLightPos[i].xyz - posInLightSpace.xyz);\n"
"            float density = 1.0;\n"
"            if (uDoubleSided != 0)\n"
"            {\n"
"            	density = abs(dot(normalInLightSpace, lv));\n"
"            }\n"
"            else\n"
"            {\n"
"                density = clamp(dot(normalInLightSpace, lv), 0.0, 1.0);\n"
"			}\n"
"            vDensity += density * atten;\n"
"            lightResult += vec4(uMaterialDiffuse.xyz * uLightColor[i].xyz * density, uMaterialDiffuse.w) * atten;\n"
"            \n"
"            // specular light\n"
"            if (uMaterialSpec.w > 0.01 && density > 0.0)\n"
"            {\n"
"                float specPower = 0.0;\n"
"                vec3 camVec = normalize(uEyePosition - posInLightSpace.xyz);\n"
"                vec3 halfV = normalize(lv + camVec);\n"
"                specPower = pow(max(0.0, dot(halfV, normalInLightSpace)), uShininess);\n"
"                lightResult += vec4(uMaterialSpec.xyz * normalize(uLightColor[i].xyz) * specPower, 0);\n"
"            }\n"
"        }\n"
"        lightResult = clamp(lightResult, 0.0, 1.0);\n"
"    }\n"
"    else\n"
"    {\n"
"    	lightResult = uMaterialDiffuse;\n"
"        vDensity = 1.0;\n"
"    }\n"
"    \n"
"	if (uTextureMode == 0)\n"
"    {\n"
"        gl_FragColor = lightResult;\n"
"    }\n"
"    else\n"
"    {\n"
"        vec4 texColor = texture2D(tex, vTexcoords);\n"
"        vec4 baseColor = texColor * vDensity;\n"
"        if (uTextureMode == 1)\n"
"        {\n"
"            gl_FragColor = vec4(baseColor.xyz + lightResult.xyz, texColor.w);\n"
"        }\n"
"        else if(uTextureMode == 2)\n"
"        {\n"
"            gl_FragColor = vec4(baseColor.xyz, texColor.w);\n"
"        }\n"
"        else if(uTextureMode == 3)\n"
"        {\n"
"            gl_FragColor = baseColor * lightResult;\n"
"        }\n"
"        else if(uTextureMode == 4)\n"
"        {\n"
"            if (vTexcoords.s < 0.0 || vTexcoords.t <= 0.0)\n"
"            {\n"
"                gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
"            }\n"
"            else\n"
"            {\n"
"                gl_FragColor = vec4(baseColor.xyz + lightResult.xyz, texColor.w);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
, 
"precision highp float;\n"
"\n"
"uniform sampler2D tex;\n"
"uniform sampler2D tex_bump;\n"
"\n"
"// 0 No Texture; 1 Combine; 2 Replace; 3 Modulate\n"
"uniform int uTextureMode;\n"
"\n"
"uniform int iLightingEnabled;\n"
"uniform int iAttenuationEnabled;\n"
"uniform vec4 uLightColor[4];\n"
"uniform int uLightCount;\n"
"uniform vec4 uAmbientLight;\n"
"uniform vec4 uMaterialAmbient;\n"
"uniform vec4 uMaterialDiffuse;\n"
"uniform vec4 uMaterialSpec;\n"
"uniform float uShininess;\n"
"uniform int uDoubleSided;\n"
"uniform vec3 uEyePosition;\n"
"uniform int uIsLightPosFixed;\n"
"\n"
"varying vec2 vTexcoords;\n"
"varying vec4 vPos;\n"
"varying vec3 vNormal;\n"
"varying vec3 vLightPos;\n"
"\n"
"void main() {\n"
"\n"
"	vec3 normal = 2.0 * texture2D(tex_bump, vTexcoords.st).rgb - 1.0;\n"
"    normal = normalize (normal);\n"
"    \n"
"	float density = 0.0;\n"
"    vec4 lightResult = vec4(0.0, 0.0, 0.0, 0.0);\n"
"    if (iLightingEnabled != 0)\n"
"    {\n"
"        lightResult = uAmbientLight * uMaterialAmbient;\n"
"        vec4 posInLightSpace = vPos;\n"
"        vec3 lv = normalize(vLightPos);\n"
"        \n"
"        density = clamp(dot(normal, lv), 0.0, 1.0);\n"
"        lightResult += vec4(uMaterialDiffuse.xyz * uLightColor[0].xyz * density, uMaterialDiffuse.w);\n"
"        \n"
"        // specular light\n"
"        if (uMaterialSpec.w > 0.01 && density > 0.0)\n"
"        {\n"
"            float specPower = 0.0;\n"
"            vec3 camVec = normalize(uEyePosition - posInLightSpace.xyz);\n"
"            vec3 halfV = normalize(lv + camVec);\n"
"            specPower = pow(max(0.0, dot(halfV, normal)), uShininess);\n"
"            lightResult += vec4(uMaterialSpec.xyz * normalize(uLightColor[0].xyz) * specPower, 0);\n"
"        }\n"
"        lightResult = clamp(lightResult, 0.0, 1.0);\n"
"    }\n"
"    else\n"
"    {\n"
"    	lightResult = uMaterialDiffuse;\n"
"        density = 1.0;\n"
"    }\n"
"    \n"
"	if (uTextureMode == 0)\n"
"    {\n"
"        gl_FragColor = lightResult;\n"
"    }\n"
"    else\n"
"    {\n"
"        vec4 texColor = texture2D(tex, vTexcoords);\n"
"        vec4 baseColor = texColor * density;\n"
"        if (uTextureMode == 1)\n"
"        {\n"
"            gl_FragColor = vec4(baseColor.xyz + lightResult.xyz, texColor.w);\n"
"        }\n"
"        else if(uTextureMode == 2)\n"
"        {\n"
"            gl_FragColor = vec4(baseColor.xyz, texColor.w);\n"
"        }\n"
"        else if(uTextureMode == 3)\n"
"        {\n"
"            gl_FragColor = baseColor * lightResult;\n"
"        }\n"
"        else if(uTextureMode == 4)\n"
"        {\n"
"            if (vTexcoords.s < 0.0 || vTexcoords.t <= 0.0)\n"
"            {\n"
"                gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
"            }\n"
"            else\n"
"            {\n"
"                gl_FragColor = vec4(baseColor.xyz + lightResult.xyz, texColor.w);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
, 
"precision mediump float;\n"
"\n"
"uniform sampler2D tex;\n"
"\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"    //vec4 texColor = texture2D(tex, texcoords.st);\n"
"    //gl_FragColor = texColor;\n"
"	gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n"
"}\n"
};

#endif

